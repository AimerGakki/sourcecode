#[最佳实践]Best Practice

	-ui
		-从JavaScript中抽离HTML
			-从服务器加载，将模板放置于远程服务器，使用ajax来	获取外部标签
			-简单客户端模板，一些带“插槽”的标签片段，这些“插槽”会被JS程序替换为数据以保证模板的完整可用
			-复杂客户端模板：Handlebar（JS模板引擎）

	-global variable

		-全局变量带来的问题：
			1）命名冲突：变量难以追踪；
			2）代码的脆弱性：依赖于全局变量的函数即是深耦合于上下文环境之中，环境发生改变，函数很可能就失效；
			3）难以测试：依赖于全局变量，无法进行单元测试

		-单全局变量方式
			被分割的代码之间能够相互通信的唯一方式就是所有代码都对某个全局变量有相同的依赖。

			-命名空间 namespace

		-模块：通用的功能片段

			-YUI模式(YUI.add(),YUI().user())

			-异步模块模式（AMD）：require.js

		-零全局变量（完全独立的脚本）

	-event

		-规则1：隔离应该逻辑

		-规则2：不要分发event对象

	-compare

		-检测原始值 typeof（string,number,boolean,undefined,function）
					但是不能对null进行检测，低效的做法

		-检测引用值（也称为对象）instanceof
			typeof 引用值 返回都是 object

		-检测函数 typeof或者 in

		-检测数组
			-鸭式辨型
			-Kangax（ECMA5和类库采用的方式）

		-检测属性
			in & hasOwnProperty()

	-config data
		【避免HardCoded】
		-配置数据：
			·URL
			·需要展示给用户的字符串
			·重复的值
			·设置
			·任何可能发生变更的值

		-抽离配置文件

		-保存配置数据
			配置文件最好放在单独的文件中，以便清晰地分隔数据和应用逻辑

	-error
		目的不是防止错误，而是在错误发生时更加容易地调试

		-try-catch
			进行错误处理
		-throw
			抛出错误，作为错误的提示，方便开发者进行调试

	-Object
		不是你的对象不要动

		·原生对象

		·DOM对象

		·浏览器对象模型（BOM）对象

		·类库的对象

		-原则
			·不覆盖方法

			·不新增方法

			·不删除方法

		-更好的途径

			-基于对象的继承（原型继承）不需要构造函数

			-基于类型的继承，需要调用构造函数

			-门面模式（包装器）
				为一个已存在的对象创建一个新的接口，
				门面是一个全新的对象，其背后有一个已存在的对象

		-polyfill
			一个shim是一个库，它将一个新的API引入到一个旧的环境中，而且仅靠旧环境已有的手段实现，而polyfill是一种功能的模拟，它就是一个用在浏览器API上的shim，通常的做法是先检查当前浏览器是否支持某个API，如果不支持的话就加载对应的polyfill，然后新旧浏览器就可以使用这个API了。

		-阻止修改

	-user-agent
		浏览器嗅探技术，即代理检测

		-UserAgent
			缺点是要不断更新代码来适用新版本的浏览器，不是一种长期可行的办法

		-特性检测
			为特定的浏览器的特性进行测试，并仅当特性存在时即可应用特性检测

				·探测标准的方法

				·探测不同的浏览器的特定方法

				·当被探测的方法均不存在时提供一个合乎逻辑的备用方法

		-避免特性推断
			特性推断是指尝试使用多个特性但仅验证了其中之一，根据一
			个特性的存在推断另一个特性是否存在

		-避免浏览器推断

	-文件和目录结构

		-最佳实践
			-