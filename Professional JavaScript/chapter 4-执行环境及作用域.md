#JavaScript 高级程序设计

### 执行环境及作用域

#### 基本概念

>执行环境（execution context）定义了变量或函数有权访问的其他数据，决定了它们各自的行为。

>每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。

>全局执行环境是最外围的一个执行环境，当某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。

>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain），作用域的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域的前端，始终都是当前执行的代码所在环境的变量对象。

>如果这个环境是函数，则将其活动对象（activation object）作为变量对象，活动对象在最开始时只包含一个变量，即arguments对象

>作用域链中的下一个变量对象来自包含（外部）环境，而在下一个变量对象则来自下一个包含环境，这样一直延续到全局执行环境，全局执行环境的变量对象始终都是作用域链中的最后一个对象

>标识符解析是沿着作用域链一级一级地搜索标识符的过程，搜索过程始终从作用域的前端开始，然后逐级地向后回溯吗，直至找到标识符为止。

```javascript
	var color = "blue";
	function changeColor(){
		var anotherColor = "red";
		function swapColors(){
		var tempColor = anotherColor;
		anotherColor = color;
		color = tempColor;
		}
		swapColors();
	}
	// 这里只能访问color
	changeColor();
```

#### 延长作用域链

>这么说因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除
	
	1. try-catch语句的catch块
	
	2. with语句

#### 没有块级作用域

#### 查询标识符

>搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。

```javascript
	var color = 'blue';
	function getColor(){
		return color;
	}
	console.log(getColor()); //blue
```

### 垃圾收集

>JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理执行过程中使用的内存。

>垃圾收集机制的原理：找到那些不再继续使用的变量，然后释放其占用的内存

#### 垃圾收集机制策略

**标记清除（mark-and-sweep）**

>JavaScript中最常用的垃圾收集方式当变量进入环境时，就将这个变量标记为“进入环境”，从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们，而当变量离开环境时，则将其标记为“离开环境”。

>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记，在此之后，在被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收它们所占用的内存空间。

**引用计数（reference counting）**

>不太常见的垃圾收集策略。原理是：跟踪记录每个值被引用的次数，当声明了一个变量并且一个引用类型赋值给变量时，则这个值的引用次数就是1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样当垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。
	
*这种策略有个严重的问题：循环引用*

```javascript	
	function problem(){
		var objA = {},
			objB = {};
		objA.someOtherObject = objB;
		objB.someOtherObject = objA;
	}	
```

*objA和objB通过各自的属性相互引用，它们的引用次数都是2，如果才有引用计数的策略
，由于objA，objB的引用次数永远不会 是0，那么它们在函数执行完毕后，还会继续存在*


>在IE中，有一部分对象并不是原生的JavaScript对象，而是使用c++以COM对象的形式实现的，COM对象的垃圾收集机制采用的就是引用计数策略。也就是说，在IE中涉及COM对象，就会存在循环引用的问题。

#### 性能问题

>垃圾收集器是周期性运行的，而且如果为变量分配内存数量很可观，那么回收工作量也是相当大的，在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。

*之前IE的垃圾收集器是根据内存分配量运行的，导致性能不佳*

####管理内存

>虽然JavaScript具备垃圾收集机制，但是由于Web浏览器的可用内存数量通常要比分配给桌面应用程序的少，因此确保占用最少的内存可以让页面获得更好的性能。

**限制内存**

>处于安全方面的考虑，防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。

####解除引用（dereferencing）：

>一旦数据不再有用，最好通过将其值设置为null来释放其引用，这样做并不意味着自动回收该值所占用的内存，而是让值脱离执行环境，以便垃圾收集器在下次运行时将其回收。









